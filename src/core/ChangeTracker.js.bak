import crypto from "crypto";
/**
 * ChangeTracker - Content Change Detection and Analysis
 * Implements hierarchical content hashing (page → sections → elements)
 * with differential comparison engine and change significance scoring
 */

import { createHash } from 'crypto';
import { z } from 'zod';
import { EventEmitter } from 'events';
import { load } from 'cheerio';
import { diffWords, diffLines, diffChars } from 'diff';

const ChangeTrackingSchema = z.object({
  url: z.string().url(),
  content: z.string(),
  html: z.string().optional(),
  options: z.object({
    granularity: z.enum(['page', 'section', 'element', 'text']).default('section'),
    trackText: z.boolean().default(true),
    trackStructure: z.boolean().default(true),
    trackAttributes: z.boolean().default(false),
    trackImages: z.boolean().default(false),
    trackLinks: z.boolean().default(true),
    ignoreWhitespace: z.boolean().default(true),
    ignoreCase: z.boolean().default(false),
    customSelectors: z.array(z.string()).optional(),
    excludeSelectors: z.array(z.string()).optional().default([
      'script', 'style', 'noscript', '.advertisement', '.ad'
    ]),
    significanceThresholds: z.object({
      minor: z.number().min(0).max(1).default(0.1),
      moderate: z.number().min(0).max(1).default(0.3),
      major: z.number().min(0).max(1).default(0.7)
    }).optional()
  }).optional().default({})
});

const ChangeComparisonSchema = z.object({
  baselineUrl: z.string().url(),
  currentUrl: z.string().url(),
  baselineContent: z.string(),
  currentContent: z.string(),
  options: z.object({}).optional()
});

const ChangeSignificance = z.enum(['none', 'minor', 'moderate', 'major', 'critical']);

export class ChangeTracker extends EventEmitter {
  constructor(options = {}) {
    super();
    
    this.options = {
      hashAlgorithm: 'sha256',
      maxHistoryLength: 100,
      enableRealTimeTracking: true,
      monitoringInterval: 300000, // 5 minutes
      enableChangeSignificanceScoring: true,
      enableStructuralAnalysis: true,
      enableSemanticAnalysis: false,
      contentSimilarityThreshold: 0.8,
      ...options
    };
    
    // Content snapshots and hashes
    this.snapshots = new Map();
    this.contentHashes = new Map();
    this.changeHistory = new Map();
    this.structuralHashes = new Map();
    
    // Change detection state
    this.activeMonitors = new Map();
    this.lastProcessedTimestamps = new Map();
    
    // Statistics
    this.stats = {
      pagesTracked: 0,
      changesDetected: 0,
      significantChanges: 0,
      structuralChanges: 0,
      contentChanges: 0,
      falsePositives: 0,
      averageChangeScore: 0,
      lastAnalysis: null,
      processingTime: 0
    };
    
    // Semantic analysis tools (if enabled)
    this.semanticAnalyzer = null;
    
    this.initialize();
  }
  
  async initialize() {
    // Initialize semantic analysis if enabled
    if (this.options.enableSemanticAnalysis) {
      await this.initializeSemanticAnalyzer();
    }
    
    this.emit('initialized');
  }
  
  /**
   * Create baseline snapshot for change tracking
   * @param {string} url - URL to track
   * @param {string} content - Content to establish as baseline
   * @param {Object} options - Tracking options
   * @returns {Object} - Baseline snapshot information
   */
  async createBaseline(url, content, options = {}) {
    const startTime = Date.now();
    
    try {
      const validated = ChangeTrackingSchema.parse({ url, content, options });
      const { granularity, trackText, trackStructure } = validated.options;
      
      // Generate hierarchical content hashes
      const contentAnalysis = await this.analyzeContent(content, validated.options);
      
      const baseline = {
        url,
        timestamp: Date.now(),
        contentLength: content.length,
        granularity,
        analysis: contentAnalysis,
        options: validated.options,
        version: 1
      };
      
      // Store baseline
      this.snapshots.set(url, [baseline]);
      this.contentHashes.set(url, contentAnalysis.hashes);
      this.changeHistory.set(url, []);
      this.lastProcessedTimestamps.set(url, Date.now());
      
      this.stats.pagesTracked++;
      this.stats.processingTime += Date.now() - startTime;
      
      this.emit('baselineCreated', {
        url,
        baseline,
        processingTime: Date.now() - startTime
      });
      
      return {
        success: true,
        url,
        version: 1,
        contentHash: contentAnalysis.hashes.page,
        sections: Object.keys(contentAnalysis.hashes.sections).length,
        elements: Object.keys(contentAnalysis.hashes.elements).length,
        createdAt: baseline.timestamp
      };
      
    } catch (error) {
      this.emit('error', { operation: 'createBaseline', url, error: error.message });
      throw new Error(`Failed to create baseline for ${url}: ${error.message}`);
    }
  }
  
  /**
   * Compare current content against baseline
   * @param {string} url - URL to compare
   * @param {string} currentContent - Current content
   * @param {Object} options - Comparison options
   * @returns {Object} - Change analysis results
   */
  async compareWithBaseline(url, currentContent, options = {}) {
    const startTime = Date.now();
    
    try {
      if (!this.snapshots.has(url)) {
        throw new Error(`No baseline found for URL: ${url}`);
      }
      
      const snapshots = this.snapshots.get(url);
      const baseline = snapshots[snapshots.length - 1]; // Get latest baseline
      
      const validated = ChangeComparisonSchema.parse({
        baselineUrl: url,
        currentUrl: url,
        baselineContent: baseline.analysis.originalContent || '',
        currentContent,
        options
      });
      
      // Analyze current content
      const currentAnalysis = await this.analyzeContent(currentContent, baseline.options);
      
      // Perform comprehensive change detection
      const changeAnalysis = await this.detectChanges(
        baseline.analysis,
        currentAnalysis,
        baseline.options
      );
      
      // Calculate change significance
      const significance = await this.calculateChangeSignificance(changeAnalysis, baseline.options);
      
      // Create change record
      const changeRecord = {
        url,
        timestamp: Date.now(),
        baselineVersion: baseline.version,
        changeType: this.classifyChangeType(changeAnalysis),
        significance,
        details: changeAnalysis,
        metrics: {
          contentSimilarity: changeAnalysis.similarity,
          structuralSimilarity: changeAnalysis.structuralSimilarity,
          addedElements: changeAnalysis.addedElements?.length || 0,
          removedElements: changeAnalysis.removedElements?.length || 0,
          modifiedElements: changeAnalysis.modifiedElements?.length || 0
        },
        processingTime: 0
      };
      
      changeRecord.processingTime = Date.now() - startTime;
      
      // Store change record
      const changeHistory = this.changeHistory.get(url);
      changeHistory.push(changeRecord);
      
      // Update statistics
      this.updateStats(changeRecord);
      
      // Update content hashes if significant change
      if (significance !== 'none') {
        this.contentHashes.set(url, currentAnalysis.hashes);
      }
      
      this.emit('changeDetected', changeRecord);
      
      return {
        hasChanges: significance !== 'none',
        significance,
        changeType: changeRecord.changeType,
        summary: this.generateChangeSummary(changeAnalysis),
        details: changeAnalysis,
        metrics: changeRecord.metrics,
        recommendations: this.generateChangeRecommendations(changeRecord)
      };
      
    } catch (error) {
      this.emit('error', { operation: 'compareWithBaseline', url, error: error.message });
      throw new Error(`Failed to compare content for ${url}: ${error.message}`);
    }
  }
  
  /**
   * Analyze content structure and create hierarchical hashes
   * @param {string} content - Content to analyze
   * @param {Object} options - Analysis options
   * @returns {Object} - Content analysis results
   */
  async analyzeContent(content, options = {}) {
    const analysis = {
      originalContent: content,
      hashes: {
        page: this.hashContent(content),
        sections: {},
        elements: {},
        text: {}
      },
      structure: {},
      metadata: {},
      statistics: {}
    };
    
    try {
      // Parse HTML if available
      const $ = load(content);
      
      // Remove excluded elements
      options.excludeSelectors?.forEach(selector => {
        $(selector).remove();
      });
      
      // Analyze at different granularities
      switch (options.granularity) {
        case 'element':
          await this.analyzeElementLevel($, analysis, options);
          break;
        case 'section':
          await this.analyzeSectionLevel($, analysis, options);
          break;
        case 'text':
          await this.analyzeTextLevel($, analysis, options);
          break;
        default:
          await this.analyzePageLevel($, analysis, options);
      }
      
      // Extract structural information
      if (options.trackStructure) {
        analysis.structure = this.extractStructure($, options);
      }
      
      // Extract metadata
      analysis.metadata = this.extractMetadata($, options);
      
      // Calculate statistics
      analysis.statistics = this.calculateContentStatistics(content, $);
      
    } catch (error) {
      // Fallback to plain text analysis
      analysis.hashes.text.plain = this.hashContent(content);
      analysis.statistics = {
        contentLength: content.length,
        wordCount: content.split(/\s+/).length,
        error: error.message
      };
    }
    
    return analysis;
  }
  
  /**
   * Detect changes between two content analyses
   * @param {Object} baseline - Baseline content analysis
   * @param {Object} current - Current content analysis
   * @param {Object} options - Detection options
   * @returns {Object} - Change detection results
   */
  async detectChanges(baseline, current, options = {}) {
    const changes = {
      similarity: 0,
      structuralSimilarity: 0,
      addedElements: [],
      removedElements: [],
      modifiedElements: [],
      textChanges: [],
      structuralChanges: [],
      attributeChanges: [],
      imageChanges: [],
      linkChanges: []
    };
    
    // Calculate overall content similarity
    changes.similarity = this.calculateSimilarity(
      baseline.hashes.page,
      current.hashes.page
    );
    
    // Detect structural changes
    if (options.trackStructure) {
      changes.structuralChanges = await this.detectStructuralChanges(
        baseline.structure,
        current.structure
      );
      
      changes.structuralSimilarity = this.calculateStructuralSimilarity(
        baseline.structure,
        current.structure
      );
    }
    
    // Detect section-level changes
    const sectionChanges = this.detectHashChanges(
      baseline.hashes.sections,
      current.hashes.sections
    );
    
    changes.addedElements.push(...sectionChanges.added);
    changes.removedElements.push(...sectionChanges.removed);
    changes.modifiedElements.push(...sectionChanges.modified);
    
    // Detect element-level changes
    if (baseline.hashes.elements && current.hashes.elements) {
      const elementChanges = this.detectHashChanges(
        baseline.hashes.elements,
        current.hashes.elements
      );
      
      changes.addedElements.push(...elementChanges.added);
      changes.removedElements.push(...elementChanges.removed);
      changes.modifiedElements.push(...elementChanges.modified);
    }
    
    // Detect text changes
    if (options.trackText) {
      changes.textChanges = await this.detectTextChanges(
        baseline.originalContent,
        current.originalContent,
        options
      );
    }
    
    // Detect link changes
    if (options.trackLinks) {
      changes.linkChanges = this.detectLinkChanges(
        baseline.metadata.links || [],
        current.metadata.links || []
      );
    }
    
    // Detect image changes
    if (options.trackImages) {
      changes.imageChanges = this.detectImageChanges(
        baseline.metadata.images || [],
        current.metadata.images || []
      );
    }
    
    return changes;
  }
  
  /**
   * Calculate change significance score
   * @param {Object} changeAnalysis - Change analysis results
   * @param {Object} options - Scoring options
   * @returns {string} - Significance level
   */
  async calculateChangeSignificance(changeAnalysis, options = {}) {
    const thresholds = options.significanceThresholds || {
      minor: 0.1,
      moderate: 0.3,
      major: 0.7
    };
    
    let significanceScore = 0;
    const weights = {
      similarity: 0.3,
      structural: 0.2,
      additions: 0.15,
      removals: 0.15,
      modifications: 0.1,
      textChanges: 0.1
    };
    
    // Content similarity impact (inverted - less similarity = more significant)
    significanceScore += (1 - changeAnalysis.similarity) * weights.similarity;
    
    // Structural changes impact
    if (changeAnalysis.structuralChanges.length > 0) {
      significanceScore += Math.min(changeAnalysis.structuralChanges.length * 0.1, 1) * weights.structural;
    }
    
    // Element changes impact
    const totalElements = changeAnalysis.addedElements.length +
                         changeAnalysis.removedElements.length +
                         changeAnalysis.modifiedElements.length;
    
    significanceScore += Math.min(totalElements * 0.05, 1) * 
      (weights.additions + weights.removals + weights.modifications);
    
    // Text changes impact
    if (changeAnalysis.textChanges.length > 0) {
      const textChangeRatio = changeAnalysis.textChanges.reduce(
        (sum, change) => sum + (change.added?.length || 0) + (change.removed?.length || 0),
        0
      ) / 1000; // Normalize by character count
      
      significanceScore += Math.min(textChangeRatio, 1) * weights.textChanges;
    }
    
    // Determine significance level
    if (significanceScore < thresholds.minor) {
      return 'none';
    } else if (significanceScore < thresholds.moderate) {
      return 'minor';
    } else if (significanceScore < thresholds.major) {
      return 'moderate';
    } else if (significanceScore < 0.9) {
      return 'major';
    } else {
      return 'critical';
    }
  }
  
  // Content Analysis Methods
  
  async analyzePageLevel($, analysis, options) {
    const pageContent = $.html();
    analysis.hashes.page = this.hashContent(pageContent);
    
    if (options.trackText) {
      const textContent = $.text();
      analysis.hashes.text.page = this.hashContent(textContent);
    }
  }
  
  async analyzeSectionLevel($, analysis, options) {
    const sections = ['header', 'nav', 'main', 'article', 'section', 'aside', 'footer'];
    
    sections.forEach(tag => {
      $(tag).each((index, element) => {
        const sectionKey = `${tag}_${index}`;
        const sectionContent = $(element).html() || '';
        analysis.hashes.sections[sectionKey] = this.hashContent(sectionContent);
        
        if (options.trackText) {
          const textContent = $(element).text() || '';
          analysis.hashes.text[sectionKey] = this.hashContent(textContent);
        }
      });
    });
    
    // Handle custom selectors
    if (options.customSelectors) {
      options.customSelectors.forEach((selector, index) => {
        $(selector).each((elemIndex, element) => {
          const key = `custom_${index}_${elemIndex}`;
          const content = $(element).html() || '';
          analysis.hashes.sections[key] = this.hashContent(content);
        });
      });
    }
  }
  
  async analyzeElementLevel($, analysis, options) {
    // Analyze common important elements
    const importantElements = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'div', 'span', 'a'];
    
    importantElements.forEach(tag => {
      $(tag).each((index, element) => {
        const elementKey = `${tag}_${index}`;
        const elementContent = $(element).html() || '';
        analysis.hashes.elements[elementKey] = this.hashContent(elementContent);
        
        if (options.trackAttributes) {
          const attributes = element.attribs || {};
          analysis.hashes.elements[`${elementKey}_attr`] = this.hashContent(JSON.stringify(attributes));
        }
      });
    });
  }
  
  async analyzeTextLevel($, analysis, options) {
    const textNodes = [];
    
    // Extract all text nodes
    $('*').contents().filter(function() {
      return this.type === 'text' && $(this).text().trim();
    }).each((index, node) => {
      const text = $(node).text().trim();
      if (text) {
        textNodes.push(text);
        analysis.hashes.text[`text_${index}`] = this.hashContent(text);
      }
    });
  }
  
  extractStructure($, options) {
    const structure = {
      elements: [],
      hierarchy: {},
      semanticStructure: {}
    };
    
    // Extract DOM hierarchy
    $('*').each((index, element) => {
      const tagName = element.name;
      const depth = $(element).parents().length;
      const hasChildren = $(element).children().length > 0;
      
      structure.elements.push({
        tag: tagName,
        index,
        depth,
        hasChildren,
        classes: element.attribs?.class?.split(' ') || [],
        id: element.attribs?.id
      });
    });
    
    // Extract semantic structure
    const semanticTags = ['header', 'nav', 'main', 'article', 'section', 'aside', 'footer'];
    semanticTags.forEach(tag => {
      structure.semanticStructure[tag] = $(tag).length;
    });
    
    return structure;
  }
  
  extractMetadata($, options) {
    const metadata = {
      title: $('title').text() || '',
      headings: [],
      links: [],
      images: [],
      scripts: [],
      forms: []
    };
    
    // Extract headings
    $('h1, h2, h3, h4, h5, h6').each((index, element) => {
      metadata.headings.push({
        tag: element.name,
        text: $(element).text().trim(),
        level: parseInt(element.name.replace('h', ''))
      });
    });
    
    // Extract links
    if (options.trackLinks) {
      $('a[href]').each((index, element) => {
        metadata.links.push({
          href: $(element).attr('href'),
          text: $(element).text().trim(),
          external: this.isExternalLink($(element).attr('href'))
        });
      });
    }
    
    // Extract images
    if (options.trackImages) {
      $('img[src]').each((index, element) => {
        metadata.images.push({
          src: $(element).attr('src'),
          alt: $(element).attr('alt') || '',
          title: $(element).attr('title') || ''
        });
      });
    }
    
    return metadata;
  }
  
  calculateContentStatistics(content, $) {
    return {
      contentLength: content.length,
      htmlLength: $.html().length,
      textLength: $.text().length,
      wordCount: $.text().split(/\s+/).filter(word => word.length > 0).length,
      elementCount: $('*').length,
      linkCount: $('a').length,
      imageCount: $('img').length,
      scriptCount: $('script').length
    };
  }
  
  // Change Detection Methods
  
  detectHashChanges(baselineHashes, currentHashes) {
    const changes = {
      added: [],
      removed: [],
      modified: []
    };
    
    const baselineKeys = new Set(Object.keys(baselineHashes));
    const currentKeys = new Set(Object.keys(currentHashes));
    
    // Find added elements
    for (const key of currentKeys) {
      if (!baselineKeys.has(key)) {
        changes.added.push(key);
      }
    }
    
    // Find removed elements
    for (const key of baselineKeys) {
      if (!currentKeys.has(key)) {
        changes.removed.push(key);
      }
    }
    
    // Find modified elements
    for (const key of baselineKeys) {
      if (currentKeys.has(key) && baselineHashes[key] !== currentHashes[key]) {
        changes.modified.push({
          key,
          oldHash: baselineHashes[key],
          newHash: currentHashes[key]
        });
      }
    }
    
    return changes;
  }
  
  async detectStructuralChanges(baselineStructure, currentStructure) {
    const changes = [];
    
    // Compare element counts by type
    const baselineCounts = this.countElementTypes(baselineStructure);
    const currentCounts = this.countElementTypes(currentStructure);
    
    for (const [element, baselineCount] of baselineCounts) {
      const currentCount = currentCounts.get(element) || 0;
      if (currentCount !== baselineCount) {
        changes.push({
          type: 'element_count_change',
          element,
          oldCount: baselineCount,
          newCount: currentCount,
          difference: currentCount - baselineCount
        });
      }
    }
    
    // Check for new element types
    for (const [element, currentCount] of currentCounts) {
      if (!baselineCounts.has(element)) {
        changes.push({
          type: 'new_element_type',
          element,
          count: currentCount
        });
      }
    }
    
    return changes;
  }
  
  async detectTextChanges(baselineContent, currentContent, options = {}) {
    const textChanges = [];
    
    if (options.ignoreWhitespace) {
      baselineContent = baselineContent.replace(/\s+/g, ' ').trim();
      currentContent = currentContent.replace(/\s+/g, ' ').trim();
    }
    
    if (options.ignoreCase) {
      baselineContent = baselineContent.toLowerCase();
      currentContent = currentContent.toLowerCase();
    }
    
    // Word-level diff
    const wordDiff = diffWords(baselineContent, currentContent);
    textChanges.push({
      type: 'word_diff',
      changes: wordDiff.filter(part => part.added || part.removed)
    });
    
    // Line-level diff for structured content
    const lineDiff = diffLines(baselineContent, currentContent);
    if (lineDiff.some(part => part.added || part.removed)) {
      textChanges.push({
        type: 'line_diff',
        changes: lineDiff.filter(part => part.added || part.removed)
      });
    }
    
    return textChanges;
  }
  
  detectLinkChanges(baselineLinks, currentLinks) {
    const changes = {
      added: [],
      removed: [],
      modified: []
    };
    
    const baselineMap = new Map(baselineLinks.map(link => [link.href, link]));
    const currentMap = new Map(currentLinks.map(link => [link.href, link]));
    
    // Find added links
    for (const [href, link] of currentMap) {
      if (!baselineMap.has(href)) {
        changes.added.push(link);
      }
    }
    
    // Find removed links
    for (const [href, link] of baselineMap) {
      if (!currentMap.has(href)) {
        changes.removed.push(link);
      }
    }
    
    // Find modified links (text changes)
    for (const [href, baselineLink] of baselineMap) {
      const currentLink = currentMap.get(href);
      if (currentLink && currentLink.text !== baselineLink.text) {
        changes.modified.push({
          href,
          oldText: baselineLink.text,
          newText: currentLink.text
        });
      }
    }
    
    return changes;
  }
  
  detectImageChanges(baselineImages, currentImages) {
    const changes = {
      added: [],
      removed: [],
      modified: []
    };
    
    const baselineMap = new Map(baselineImages.map(img => [img.src, img]));
    const currentMap = new Map(currentImages.map(img => [img.src, img]));
    
    // Find added images
    for (const [src, img] of currentMap) {
      if (!baselineMap.has(src)) {
        changes.added.push(img);
      }
    }
    
    // Find removed images
    for (const [src, img] of baselineMap) {
      if (!currentMap.has(src)) {
        changes.removed.push(img);
      }
    }
    
    // Find modified images (alt text changes)
    for (const [src, baselineImg] of baselineMap) {
      const currentImg = currentMap.get(src);
      if (currentImg && (currentImg.alt !== baselineImg.alt || currentImg.title !== baselineImg.title)) {
        changes.modified.push({
          src,
          oldAlt: baselineImg.alt,
          newAlt: currentImg.alt,
          oldTitle: baselineImg.title,
          newTitle: currentImg.title
        });
      }
    }
    
    return changes;
  }
  
  // Utility Methods
  
  hashContent(content) {
    return createHash(this.options.hashAlgorithm)
      .update(content || '')
      .digest('hex');
  }
  
  calculateSimilarity(hash1, hash2) {
    if (hash1 === hash2) return 1;
    
    // Simple similarity based on hash difference
    // In production, you might want to use more sophisticated algorithms
    const diff = this.hammingDistance(hash1, hash2);
    const maxLength = Math.max(hash1.length, hash2.length);
    return 1 - (diff / maxLength);
  }
  
  calculateStructuralSimilarity(baseline, current) {
    if (!baseline || !current) return 0;
    
    const baselineElements = baseline.elements || [];
    const currentElements = current.elements || [];
    
    if (baselineElements.length === 0 && currentElements.length === 0) return 1;
    if (baselineElements.length === 0 || currentElements.length === 0) return 0;
    
    const tagSimilarity = this.calculateTagSimilarity(baselineElements, currentElements);
    const hierarchySimilarity = this.calculateHierarchySimilarity(baseline.hierarchy, current.hierarchy);
    
    return (tagSimilarity + hierarchySimilarity) / 2;
  }
  
  calculateTagSimilarity(baselineElements, currentElements) {
    const baselineTags = baselineElements.map(el => el.tag);
    const currentTags = currentElements.map(el => el.tag);
    
    const intersection = baselineTags.filter(tag => currentTags.includes(tag));
    const union = new Set([...baselineTags, ...currentTags]);
    
    return intersection.length / union.size;
  }
  
  calculateHierarchySimilarity(baseline, current) {
    // Simple structural comparison - can be enhanced
    if (!baseline || !current) return 0;
    return Object.keys(baseline).length === Object.keys(current).length ? 1 : 0.5;
  }
  
  hammingDistance(str1, str2) {
    if (str1.length !== str2.length) {
      return Math.abs(str1.length - str2.length);
    }
    
    let distance = 0;
    for (let i = 0; i < str1.length; i++) {
      if (str1[i] !== str2[i]) {
        distance++;
      }
    }
    return distance;
  }
  
  countElementTypes(structure) {
    const counts = new Map();
    
    if (structure.elements) {
      structure.elements.forEach(element => {
        counts.set(element.tag, (counts.get(element.tag) || 0) + 1);
      });
    }
    
    return counts;
  }
  
  isExternalLink(href) {
    if (!href) return false;
    return href.startsWith('http://') || href.startsWith('https://');
  }
  
  classifyChangeType(changeAnalysis) {
    const { addedElements, removedElements, modifiedElements, structuralChanges } = changeAnalysis;
    
    if (structuralChanges.length > 0) {
      return 'structural';
    }
    
    if (addedElements.length > removedElements.length) {
      return 'content_addition';
    }
    
    if (removedElements.length > addedElements.length) {
      return 'content_removal';
    }
    
    if (modifiedElements.length > 0) {
      return 'content_modification';
    }
    
    return 'text_change';
  }
  
  generateChangeSummary(changeAnalysis) {
    const { addedElements, removedElements, modifiedElements, similarity } = changeAnalysis;
    
    const total = addedElements.length + removedElements.length + modifiedElements.length;
    
    return {
      totalChanges: total,
      contentSimilarity: Math.round(similarity * 100),
      added: addedElements.length,
      removed: removedElements.length,
      modified: modifiedElements.length,
      changeDescription: this.generateChangeDescription(changeAnalysis)
    };
  }
  
  generateChangeDescription(changeAnalysis) {
    const { addedElements, removedElements, modifiedElements, textChanges } = changeAnalysis;
    
    const descriptions = [];
    
    if (addedElements.length > 0) {
      descriptions.push(`${addedElements.length} elements added`);
    }
    
    if (removedElements.length > 0) {
      descriptions.push(`${removedElements.length} elements removed`);
    }
    
    if (modifiedElements.length > 0) {
      descriptions.push(`${modifiedElements.length} elements modified`);
    }
    
    if (textChanges.length > 0) {
      descriptions.push('Text content changed');
    }
    
    return descriptions.join(', ') || 'No significant changes detected';
  }
  
  generateChangeRecommendations(changeRecord) {
    const recommendations = [];
    const { significance, details, changeType } = changeRecord;
    
    if (significance === 'critical') {
      recommendations.push({
        type: 'alert',
        priority: 'high',
        message: 'Critical changes detected. Manual review recommended.'
      });
    }
    
    if (changeType === 'structural') {
      recommendations.push({
        type: 'monitoring',
        priority: 'medium',
        message: 'Structural changes may affect scraping selectors.'
      });
    }
    
    if (details.similarity < 0.5) {
      recommendations.push({
        type: 'analysis',
        priority: 'medium',
        message: 'Low content similarity suggests major content changes.'
      });
    }
    
    return recommendations;
  }
  
  updateStats(changeRecord) {
    this.stats.changesDetected++;
    
    if (changeRecord.significance !== 'none') {
      this.stats.significantChanges++;
    }
    
    if (changeRecord.changeType === 'structural') {
      this.stats.structuralChanges++;
    } else {
      this.stats.contentChanges++;
    }
    
    // Update average change score
    this.stats.averageChangeScore = 
      (this.stats.averageChangeScore * (this.stats.changesDetected - 1) + 
       changeRecord.details.similarity) / this.stats.changesDetected;
    
    this.stats.lastAnalysis = changeRecord.timestamp;
    this.stats.processingTime += changeRecord.processingTime;
  }
  
  // Public API Methods
  
  getStats() {
    return {
      ...this.stats,
      monitoredUrls: this.snapshots.size,
      totalSnapshots: Array.from(this.snapshots.values()).reduce((sum, snapshots) => sum + snapshots.length, 0),
      averageProcessingTime: this.stats.changesDetected > 0 ? 
        this.stats.processingTime / this.stats.changesDetected : 0
    };
  }
  
  getChangeHistory(url, limit = 50) {
    const history = this.changeHistory.get(url) || [];
    return history.slice(-limit).reverse();
  }
  
  clearHistory(url) {
    if (url) {
      this.changeHistory.set(url, []);
      this.emit('historyCleared', url);
    } else {
      this.changeHistory.clear();
      this.emit('allHistoryCleared');
    }
  }
  
  resetStats() {
    this.stats = {
      pagesTracked: 0,
      changesDetected: 0,
      significantChanges: 0,
      structuralChanges: 0,
      contentChanges: 0,
      falsePositives: 0,
      averageChangeScore: 0,
      lastAnalysis: null,
      processingTime: 0
    };
  }
  

  /**
   * Generate content hash
   */
  generateContentHash(content) {

    return crypto.createHash("sha256").update(content).digest("hex");
  }

  /**
   * Create snapshot of content
   */
  async createSnapshot(url, content) {
    const timestamp = Date.now();
    const hash = this.generateContentHash(content);
    
    const snapshot = {
      url,
      content,
      hash,
      timestamp,
      version: 1
    };
    
    // Store snapshot in cache
    if (!this.contentHistory.has(url)) {
      this.contentHistory.set(url, []);
    }
    
    this.contentHistory.get(url).unshift(snapshot);
    
    // Keep only last 100 snapshots
    const history = this.contentHistory.get(url);
    if (history.length > 100) {
      history.splice(100);
    }
    
    return snapshot;
  }

  /**
   * Calculate significance score for changes
   */
  calculateSignificanceScore(changes) {
    if (!changes || changes.length === 0) return 0;
    
    let score = 0;
    const weights = {
      added: 0.3,
      removed: 0.4,
      modified: 0.2
    };
    
    changes.forEach(change => {
      score += (weights[change.type] || 0.1) * (change.count || 1);
    });
    
    return Math.min(score, 1.0); // Cap at 1.0
  }

  /**
   * Start monitoring URL for changes
   */
  async startMonitoring(url, options = {}) {
    const monitorId = `monitor_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const monitor = {
      id: monitorId,
      url,
      interval: options.interval || 300000, // 5 minutes default
      enabled: true,
      lastCheck: null,
      checkCount: 0,
      changeCount: 0
    };
    
    this.activeMonitors.set(monitorId, monitor);
    
    return monitor;
  }

  /**
   * Get statistics
   */
  getStatistics() {
    return {
      totalBaselines: this.baselineContent.size,
      totalMonitors: this.activeMonitors.size,
      totalComparisons: this.stats.comparisons,
      totalChanges: this.stats.changesDetected,
      averageChangeSignificance: this.stats.averageSignificance,
      lastActivity: this.stats.lastActivity
    };
  }

  /**
   * Cleanup resources
   */
  cleanup() {
    this.contentHistory.clear();
    this.baselineContent.clear();
    this.activeMonitors.clear();
    this.changeNotifications.clear();
    this.snapshotManager.clear();
  }
  async initializeSemanticAnalyzer() {
    // Placeholder for semantic analysis initialization
    // This would integrate with NLP libraries for deeper content analysis
    this.semanticAnalyzer = {
      enabled: true,
      // Integration with libraries like compromise, natural, etc.
    };
  }
}

export default ChangeTracker;